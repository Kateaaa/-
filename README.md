
## Введение


Работа направлена на практическое освоение динамической структуры данных Стек. 
С этой целью в работе изучаются различные варианты структуры хранения стеков и разрабатываются методы и программы решения ряда задач с использованием стеков. 
В качестве области приложений выбрана тема вычисления арифметических выражений, возникающая при трансляции программ на языке программирования высокого уровня в исполняемые программы. 
При вычислении произвольных арифметических выражений возникают две основные задачи: проверка корректности введенного выражения и выполнение операций в порядке, определяемом их приоритетами 
и расстановкой скобок. Существует алгоритм, позволяющий реализовать вычисление произвольного арифметического выражения за один просмотр без хранения промежуточных результатов. 
Для реализации данного алгоритма выражение должно быть представлено в постфиксной форме. Рассматриваемые в данной работе алгоритмы являются начальным введением в область 
машинных вычислений.


## Постановка учебно-практической задачи


В рамках работы ставится задача реализации программы, обеспечивающей поддержку стеков, и разработку программных средств, производящих обработку арифметических выражений, 
включая проверку правильности записи выражения, перевод в постфиксную форму и вычисление результата.

## Руководство пользователя :smiling_imp:


Для проверки работоспособности программы выполните следующие действия : 
1. Запустите программу с помощью комбинации клавиш Ctrl + F5
2. Введите арифметическое выражение, разделяя пробелами числа и операции (кроме скобок) 
3. Посмотрите на результат работы программы, который будет выведен автоматически после ввода арифметического выражения


## Руководство программиста :innocent:


Методы класса “Stack”, описание алгоритмов. 
Включает в себя следующие методы: 

```c++
public:

	Stack();
 
	Stack(int len);
 
	Stack(const Stack<T>& s2);
 
	~Stack();

	bool empty();
	bool full();

	void push(const T& el);
	void pop();
	const T& get();
	int r_top();

	void print_stack();
	void print_stack_as_a_line();

	int bracket();
	Stack<T> postfix_form();
	double calculation(const Stack<T>& st);

	Stack operator = (const Stack<T>& st)
```
## Описание алгоритмов
  
Стек это структура данных, представляющая из себя массив, с ограниченным доступом(только к верхнему элементу). 
Операции со стеком включают в себя: добавление элемента на вершину, удаление элемента с вершины массива, взятие элемента без последующего удаления.

*Класс Stack* 


+ **Stack()**   Конструктор по умолчанию.


+ **Stack(int len)**   Конструктор. Создает стек длины len.


+ **Stack(const Stack<T>& s2)**   Конструктор копирования. Создает новый стек, в которое копирует данные уже существующего стека s2


+ **~Stack()**   Деструктор. Освобождает память. 


+ **void push(const T& el);**   – добавление элемента. Записывает n-й элемент в соответствующую ему позицию массива. Перемещает указатель вершины стека. 


+ **void pop();**   – удаление элемента с вершины массива


+ **const T& get()**   - Возвращает значение элемента массива по индексу из вершины стека. Перемещает указатель вершины на 1. 

	
+ **bool empty()**   – проверка стека на отсутствие элементов. Стек считается пустым, если указатель вершины находится на минимальном значении. 


+ **bool full()**   – проверка стека на полноту. Стек считается полным, если занята вся выделенная для него память. Вершина стека должна совпадать со значением Max_size.


+ **bool checkD**   - проверка элемента на тип. (double или нет)


+ **int bracket()**  - проверка скобок. Осуществляется посимвольно. Если встречаем открывающую скобку ‘(‘ - помещаем её в стек. Если встречаем закрывающую скобку ‘)’ – 
осуществляется проверка на пустоту. Если стек не пуст - достаем из него открывающую скобку, иначе увеличиваем счетчик ошибок на 1. 


+ **int prior(string t)**   -– проверка приоритета. На вход подается символ, возвращается приоритет введенной операции. 



## ТАБЛИЦА ПРИОРИТЕТОВ

( *приоритет* 0

) *приоритет* 1

+, - *приоритет* 2

*, / *приоритет* 3




## Stack<T> postfix_form(); перевод в постфиксную форму.

Для более подробного объяснения разберём пример 2+3*(5-4)/3-3
Движение по введенному выражению осуществляется посимвольно. Первый символ – число. Записываем его в строку. 

*Строка:* 2* 

Стек: Двигаемся дальше, следующий символ – операция, стек пуст, значит записываем символ в стек. 

*Строка:* 2*

Стек: + Следующий символ – число. Записываем в строку. 

*Строка:* 2 3 

Стек: + Далее идёт операция «умножение». Поскольку стек не пуст, сравниваем приоритеты операций. Приоритет * больше, чем приоритет + => записываем * в стек. 

*Строка:* 2 3

 Стек: + * Далее следует ‘(‘. Открывающая скобка добавляется в стек моментально. 
 
*Строка:* 2 3 

Стек: + * ( Следующий символ – число. Записываем в строку. 

*Строка:* 2 3 5 

Стек: + * ( Следующий символ – операция. Сравниваем приоритеты операций. Приоритет ‘(‘ меньше, чем ‘-‘. Записываем операцию в стек. 

*Строка:* 2 3 5 

Стек: + * ( - Далее идёт число. Записывааем в строку.

*Строка:* 2 3 5 4 

Стек: + * ( - Следующий символ – закрывающая скобка ‘)’. Так как стек не пуст, достаём из стека все операции, пока не встретим открывающую скобку, и записываем их в строку, при этом открывающая скобка удаляется из стека. 

*Строка:* 2 3 5 4 -

Стек: + * Следующий символ – операция деления ‘/’. Стек не пуст, значит сравниваем приоритеты операций. Приоритет ‘/’ равен приоритету ‘*’. Помещаем ‘*’ в строку, сравниваем ‘/’ и ‘+’. Приоритет ‘/’ больше,чем ‘+’. Помещаем в стек. 

*Строка:* 2 3 5 4 - * 

Стек: + / Следующий символ – число. Записываем в строку. 

*Строка:* 2 3 5 4 - * 3 

Стек: + / Далее идёт операция вычитания. Сравниваем приоритеты операций ‘/’ и ‘-’. Приоритет ‘/’ больше, чем ‘-’ => Помещаем ‘/’ в стек, сравниваем ‘-’ и ‘+’. Приоритеты равны, помещаем в строку ‘+’, а ‘-’ в стек. 

*Строка:* 2 3 5 4 - * 3 / + 

Стек: - Последний символ – число 3. Записываем в строку. Так как символов больше нет, достаём из стека всё, что там осталось и помещаем в стоку. 

*Строка:* 2 3 5 4 - * 3 / + 3 - 

double calculation(const Stack<T>& st); – вычисление результата. Двигаемся по строке, пока не встретим операцию. Если встретилась операция – выполняем её для двух предшествующих ей чисел. После этого в строку записывается результат операции (вместо тех самых двух чисел), операция удаляется из строки. И так далее, пока в строке не останется единственное значение – результат. Поэтапное выполнение вычислений в вышестоящем примере: Строка: 2 3 5 4 - * 3 / + 3 - Строка: 2 3 1 * 3 / + 3 - Строка: 2 3 3 / + 3 - Строка: 2 1 + 3 - Строка: 3 3 - Строка: 0 Результат вычислений – 0. Выводится на экран.


## Заключение 

В ходе выполнения работы мной был разработан класс, позволяющий выполнять арифметические операции для вводимых выражений. Для проверки ошибок скобок использовался стек. 















